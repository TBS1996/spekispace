let e;import*as o from"https://esm.sh/isomorphic-git@1.27.1";import t from"https://esm.sh/isomorphic-git@1.27.1/http/web";import*as n from"https://esm.sh/path-browserify";console.log("utils.js loaded!!!");let r=new Promise((o,t)=>{BrowserFS.configure({fs:"IndexedDB",options:{}},n=>{n?(console.error("Failed to initialize BrowserFS:",n),t(n)):(e=BrowserFS.BFSRequire("fs"),console.log("BrowserFS initialized"),o())})});export async function loadFile(o){return await r,new Promise((t,n)=>{e.readFile(o,"utf8",(e,o)=>{e?"ENOENT"===e.code?t(null):(console.error("Error reading file:",e),n("Error reading file: "+e)):t(o)})})}export async function allPaths(e){let o=[];for(let t of["cards","attributes","reviews"]){let n=`${e}/${t}`;console.log(n);try{let t=await a(n);console.log(t);let r=t.map(o=>o.replace(`${e}/`,""));console.log(r),o.push(...r)}catch(e){console.error(`Failed to get files from ${n}: ${e}`)}}return o}async function a(o){return await r,new Promise((t,n)=>{e.readdir(o,(e,r)=>{if(e){n(`Error reading directory: ${e}`);return}t(r.map(e=>`${o}/${e}`))})})}export async function cloneRepo(n,a,i,s){let l=document.getElementById("output");await r;try{console.log(`starting clone from ${a} files to ${n} with token ${i} through proxy ${s}!`),await o.clone({fs:e,http:t,cache:{},dir:n,url:a,corsProxy:s,onProgress:e=>{console.log(`${e.phase}: ${e.loaded} of ${e.total}`)},onAuth:()=>({username:"x-access-token",password:i})}),console.log("successsddd nice"),l.textContent="Repository cloned successfully!"}catch(e){l.textContent="Failed to clone repository: "+e}}async function i(t,n){console.log(`the file to add: ${n} `),await o.add({fs:e,dir:t,filepath:n}),console.log("adding file...")}export async function gitStatus(t){let n=document.getElementById("output");await r;try{console.log(`Checking git status for repo at ${t}...`);let r=await o.statusMatrix({fs:e,dir:t}),a="";for(let[e,o,t,n]of r)(o!==t||t!==n)&&(a+=`${e}: `,0===o&&0!==t?a+="Untracked\n":o!==t&&t===n?a+="Modified\n":t!==n&&(a+="Staged\n"));return a||(a="Working directory clean!"),n.textContent=a,a}catch(o){let e=`Failed to get git status: ${o}`;throw n.textContent=e,Error(e)}}export async function newReviews(t){let n=document.getElementById("output");await r;try{console.log(`Counting changed files in the 'reviews' folder within repo at '${t}'...`);let r=await o.statusMatrix({fs:e,dir:t});console.log("supp");let a=r.filter(([e,o,t,n])=>e.startsWith("reviews/")&&(o!==t||t!==n)).length;console.log("hey");let i=`Number of changed files in the 'reviews' folder: ${a}`;return n.textContent=i,console.log(i),a}catch(o){let e=`Failed to count changed files in the 'reviews' folder: ${o}`;throw n.textContent=e,console.error(e),Error(e)}}export async function validateUpstream(n,a){try{return await r,console.log(`Validating upstream connection for repository at '${n}'...`),await o.fetch({fs:e,http:t,dir:n,onAuth:()=>({username:"x-access-token",password:a}),depth:1}),console.log("Upstream connection validated successfully!"),!0}catch(e){return console.error(`Failed to validate upstream connection: ${e}`),!1}}export async function gitClone(n,a,i,s){console.log(`Initializing repository at ${n}...`),await r,await o.init({fs:e,dir:n});let l="main";console.log(`Adding remote ${a} as "origin"...`),await o.addRemote({fs:e,dir:n,remote:"origin",url:a}),await o.fetch({fs:e,http:t,corsProxy:s,dir:n,remote:"origin",singleBranch:!0,depth:1,ref:l}),console.log("Fetched refs:",await o.listBranches({fs:e,dir:n,remote:"origin"}));let c=await o.resolveRef({fs:e,dir:n,ref:"refs/remotes/origin/main"});console.log(`Commit OID for origin/main: ${c}`);let g=await o.listBranches({fs:e,dir:n});console.log("Local branches:",g),g.includes(l)?(console.log(`Branch ${l} already exists locally. Checking it out...`),console.log(`Checking out branch ${l}...`),await o.checkout({fs:e,dir:n,ref:l})):(console.log(`Creating and checking out local branch ${l}...`),console.log(`Creating local branch ${l}...`),await o.writeRef({fs:e,dir:n,ref:`refs/heads/${l}`,value:c,force:!0}),await o.writeRef({fs:e,dir:n,ref:"HEAD",value:`refs/heads/${l}`,force:!0})),console.log("Local branches:",await o.listBranches({fs:e,dir:n})),console.log("Current HEAD:",await o.resolveRef({fs:e,dir:n,ref:"HEAD"})),console.log(`Repository cloned into ${n}`)}export async function loadRec(o){await r;let t=[];return await new Promise((r,a)=>{e.readdir(o,async(i,s)=>{if(i){console.error("Error reading directory:",i),a("Error reading directory: "+i);return}let l=0;0===s.length&&r(t),s.forEach(async i=>{console.log(o),console.log(i);let c=n.join(o,i);e.stat(c,async(e,n)=>{if(e){console.error(`Error reading file stats ${c}:`,e),a("Error reading file stats: "+e);return}if(n.isDirectory()){let e=await loadRec(c);t.push(...e)}else if(n.isFile()){let e=await loadAllFiles(o);t.push(...e)}++l===s.length&&r(t)})})})}),t}export async function deleteDir(o){for(let t of(await r,console.log("deleting dir: ${dirPath}"),await new Promise((t,n)=>{e.readdir(o,(e,o)=>{e?n(e):t(o)})}))){let n=`${o}/${t}`;(await function(o){return new Promise((t,n)=>{e.stat(o,(e,o)=>{e?n(e):t(o)})})}(n)).isDirectory()?await deleteDir(n):await function(o){return new Promise((t,n)=>{e.unlink(o,e=>{e?n(e):t()})})}(n)}await new Promise((t,n)=>{e.rmdir(o,e=>{e?n(e):t()})}),console.log("deleted!")}export async function lastModified(o){return await r,new Promise((t,n)=>{e.stat(o,(e,o)=>{if(e)return t(null);t(o.mtime)})})}export async function loadFilenames(o){return await r,console.log(o),new Promise((t,n)=>{e.readdir(o,(e,o)=>{e?n(e):t(o)})})}export async function syncRepo(e,o,t){console.log("adding files.."),await s(e),console.log("commiting files.."),await c(e,o),console.log("pulling repo.."),await pullRepo(e,o,t),console.log("pushing repo.."),await pushRepo(e,o,t)}async function s(e){await r;let o=await l(e);console.log(o),console.log("Adding all files..."),await Promise.all(o.map(o=>i(e,o))),console.log("All files added!")}async function l(t){await r;let n=(await o.statusMatrix({fs:e,dir:t})).filter(e=>e[1]!==e[2]).map(e=>e[0]);return console.log(n),n}async function c(t,n){await r;let{name:a,email:i}=await g(n);await o.commit({fs:e,dir:t,message:"commit",author:{name:a,email:i}})}async function g(e){return{name:"unknown user",email:"unknown@example.com"}}export async function pullRepo(e,o,t){await fetchRepo(e,o,t),await d(e,o)}export async function fetchRepo(n,a,i){await r,console.log(`starting fetch from files to ${n} with token ${a} through proxy ${i}!`),await o.fetch({fs:e,http:t,dir:n,corsProxy:i,singleBranch:!0,onProgress:e=>{console.log(`${e.phase}: ${e.loaded} of ${e.total}`)},onAuth:()=>({username:"x-access-token",password:a})}),console.log("successsddd nice")}async function d(t,n){await r,console.log(`merging repository at '${t}...`);let{name:a,email:i}=await g(n),s=async({contents:e,path:o})=>{let t=e[0],n=e[1],r=e[2];console.log(`merging path: ${o}`);let a=/^\d{10} \d/;if(!(a.test(t)||a.test(n)||a.test(r)))return console.log(`choosing upstream commit for file: ${r} `),{cleanMerge:!0,mergedText:r};let i=[...t.split("\n"),...n.split("\n"),...r.split("\n")];console.log(i);let s=[...new Set(i)].sort();console.log(s);let l=s.join("\n").trim();return console.log(l),{cleanMerge:!0,mergedText:l}};await o.merge({fs:e,ours:"main",theirs:"remotes/origin/main",dir:t,mergeDriver:s,author:{name:a,email:i}}),console.log("Repository successfully merged with latest changes!")}export async function pushRepo(n,a,i){await r,console.log(`Pushing latest changes in the repository at '${n} with token ${a}'...`);let{name:s,email:l}=await g(a);await o.push({fs:e,http:t,cache:{},dir:n,corsProxy:i,ref:"main",onProgress:e=>{console.log(`${e.phase}: ${e.loaded} of ${e.total}`)},onAuth:()=>({username:"x-access-token",password:a}),author:{name:s,email:l}});let c="Repository successfully updated with latest changes!";return console.log(c),c}